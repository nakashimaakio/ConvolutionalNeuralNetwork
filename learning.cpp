//äwèKéûÇ…égópÇ∑ÇÈä÷êî
#include "stdafx.h"

//Ç±ÇÃÉtÉ@ÉCÉãÇÃÇ›Ç≈égópÇ∑ÇÈä÷êîÇÃêÈåæ
void Backpropagation( int channel, int TrueNumber );
void CalcDeltaF2    ( IplImage *Image, int TureNumber);
void CalcDeltaF     ( IplImage *Image );
void CalcDeltaF0    ( IplImage *Image );
void Division       ();
void CalcDivNorm    ( IplImage *   Image[FILTER_NUMBER], IplImage * InImageD[FILTER_NUMBER],  IplImage *OutImageD[FILTER_NUMBER] );
void CalcSubNorm    ( IplImage *InImageD[FILTER_NUMBER], IplImage *OutImageD[FILTER_NUMBER] );
IplImage *DeltaPool ( IplImage *Image, IplImage *NextImageD );
IplImage *DeltaConv ( IplImage *NextImageD[FILTER_NUMBER], float H[][FILTER_SIZE][FILTER_SIZE] );
void UpdateF2       ( IplImage *Image );
void UpdateF        ( IplImage *Image );
void Update         ( IplImage *Image[FILTER_NUMBER], IplImage *ImageD, float H[][FILTER_SIZE][FILTER_SIZE],
	float B, int input_number,float Hd[][FILTER_SIZE][FILTER_SIZE], float Bd );
void Update2        ( IplImage *Image, IplImage *ImageD, float H[][FILTER_SIZE],float Hd[][FILTER_SIZE]);
float UpdateFormula ( float a1, float a2, float a3);
void ReleaseDelta   ();


//äwèK
void LearningImage( IplImage *Image, int TrueNumber ){

//CNNÇÃé¿çs
	IplImage *img = CNN(Image);

//éØï åãâ ÇÃèëÇ´çûÇ›
	WriteCsv (img,TrueNumber);

//åÎç∑ãtì`îd
	Backpropagation(Image->nChannels, TrueNumber);

//âÊëúÇÃâï˙
	Release();
	ReleaseDelta();
	cvReleaseImage(&img);
	LearningCount++;
}


//åÎç∑ãtì`îdñ@
void Backpropagation(  int channel , int TrueNumber ){

//DeltaÇÃåvéZ
	//ëSåãçáëwÇÃDeltaÇÃåvéZ
	CalcDeltaF2( FcImage[2] ,TrueNumber);
	CalcDeltaF ( FcImage[1] );
	CalcDeltaF0( FcImage[0] );

	//FcImageDÇï™äÑ
	Division();

	printf("Layer:");
	for(int l=LAYER-1 ; l>=0 ; l--){
		printf("%d ",l);
		//ã«èäÉRÉìÉgÉâÉXÉgê≥ãKâªÇÃDeltaÇÃåvéZ
		CalcDivNorm( SubNormImage[l], SubNormImageD[l], DivNormImageD[l+1] );
		CalcSubNorm(   PoolImageD[l], SubNormImageD[l]);
		for(int i=0 ; i<FILTER_NUMBER ; i++){
			//ÉvÅ[ÉäÉìÉOëwÇÃDeltaÇÃåvéZ
			ConvImageD[l][i] = DeltaPool( ConvImage[l][i], PoolImageD[l][i] );
//			ShowImage("Pool",ConvImageD[l][i] );
		}
		for(int i=0 ; i<FILTER_NUMBER ; i++){
			DivNormImageD[l][i] = DeltaConv( ConvImageD[l], h[l][i] );
//			ShowImage("Conv", DivNormImageD[l][i] );
		}

	}
	puts("");
	printf("Update Weight Coefficient...\n");
//èdÇ›åWêîÇÃçXêV
	UpdateF2( FcImage[1] );
	UpdateF ( FcImage[0] );
	for(int l=0 ; l<LAYER ; l++){
	for(int j=0 ; j<FILTER_NUMBER ; j++){  //j:output
		Update(DivNormImage[l], ConvImageD[l][j], h[l][j], b[l][j], (l==0)?channel:FILTER_NUMBER, D_h[l][j], D_b[l][j] );
	}

	}

}


//deltaF2ÇÃåvéZ
void CalcDeltaF2(IplImage *Image, int TrueNumber){
	CvScalar s;

	for( int i=0 ; i<fNUMBER3 ; i++ ){
		s = cvGet2D( Image, 0, i );
		deltaF2[i] = (float)s.val[0] - ( i == TrueNumber );
	}

}


//deltaFÇÃåvéZ
void CalcDeltaF(IplImage *Image){
	CvScalar s;

	for( int i=0 ; i<fNUMBER2 ; i++ ){
		deltaF[i] = 0;
		s = cvGet2D( Image, 0, i );
		for( int k=0 ; k<fNUMBER3 ; k++ ){
			deltaF[i] += deltaF2[k] * fh2[k][i];
		}
		deltaF[i] *= (float) (s.val[0]*(1-s.val[0]));
	}
}


//deltaF0ÇÃåvéZ
void CalcDeltaF0(IplImage *Image){
	int X = Image->width, Y = Image->height;
	FcImageD = cvCreateImage(cvGetSize(Image), IPL_DEPTH_32F, 1);
	CvScalar s;
	double output;

	for(int y =0; y < Y; y++ ){
	for(int x =0; x < X; x++ ){
		output = 0;
		s = cvGet2D( Image, y, x );
		for( int k=0 ; k<fNUMBER2 ; k++ ){
			output += deltaF[k] * fh[k][y*X+x];
		}
//		output *= s.val[0]*(1-s.val[0]);
//		cout << "output:" << output << endl;
		s.val[0]=output;
		cvSet2D(FcImageD, y, x, s); 
	}
	}
}


//ï™äÑ
void Division(){
//	FcImageD;
//	DivNormImageD [LAYER][FILTER_NUMBER];
	int X = FcImageD->width, Y = FcImageD->height;
	int Xdiv = X / FILTER_NUMBER;
	CvScalar s;

	if(X % FILTER_NUMBER != 0){ Error("Error of division process in learning"); }

	for(int i=0 ; i<FILTER_NUMBER ; i++ ){
		DivNormImageD[LAYER][i] = cvCreateImage(cvSize(Xdiv,Y), IPL_DEPTH_32F, 1);
	}

	for(int y =0; y < Y; y++ ){
	for(int x =0; x < X; x++ ){
		s = cvGet2D( FcImageD, y ,x );
		cvSet2D( DivNormImageD[LAYER][x/Xdiv], y, x%Xdiv, s );
	}
	}

}


//èúéZê≥ãKâªÇÃî˜ï™ÇÃåvéZ
void CalcDivNorm( IplImage *Image[FILTER_NUMBER], IplImage *InImageD[FILTER_NUMBER],  IplImage *OutImageD[FILTER_NUMBER] ){

	IplImage *SigmaImage = cvCreateImage( cvGetSize(Image[0]), IPL_DEPTH_32F, 1);
	CvScalar sigma, s, delta;
	int X = Image[0]->width, Y = Image[0]->height;
	double dif, sum;

	//sigmaÇÃåvéZ
	for( int y=0 ; y<Y ; y++ ){
	for( int x=0 ; x<X ; x++ ){
//		sigma = cvGet2D( SigmaImage,  y,  x );
		sigma.val[0] = 0;
		for(int k=0  ;  k<FILTER_NUMBER ; k++ ){
		for(int py=0 ; py<W_FILTER_SIZE ; py++){
		for(int px=0 ; px<W_FILTER_SIZE ; px++){

			if(x+px-W_FILTER_SIZE/2>=0 && y+py-W_FILTER_SIZE/2>=0 && x+px-W_FILTER_SIZE/2<X && y+py-W_FILTER_SIZE/2<Y){
				s = cvGet2D( Image[k],  y+py-W_FILTER_SIZE/2,  x+px-W_FILTER_SIZE/2 );
				sigma.val[0] += s.val[0]*s.val[0] / ( W_FILTER_SIZE*W_FILTER_SIZE*FILTER_NUMBER );//èoóÕâÊëfÇÃåvéZ
			}

		}
		}
		}
		sigma.val[0] = sqrt(sigma.val[0]);
		cvSet2D(SigmaImage, y, x, sigma);
	}
	}


	//î˜ï™ÇÃåvéZ
	for(int k=0 ; k<FILTER_NUMBER ; k++){
	InImageD[k] = cvCreateImage(cvGetSize(OutImageD[k]), IPL_DEPTH_32F, 1);
	for(int y=0 ; y<Y ; y++){
	for(int x=0 ; x<X ; x++){
		s = cvGet2D( Image[k],  y,  x );
		sum=0;
		for(int q=0 ; q<W_FILTER_SIZE ; q++){
		for(int p=0 ; p<W_FILTER_SIZE ; p++){
		for(int r=0 ; r<FILTER_NUMBER ; r++){
			dif=0;
			if(x+p-W_FILTER_SIZE/2>=0 && y+q-W_FILTER_SIZE/2>=0 && x+p-W_FILTER_SIZE/2<X && y+q-W_FILTER_SIZE/2<Y){
				sigma = cvGet2D( SigmaImage,  y+q-W_FILTER_SIZE/2, x+p-W_FILTER_SIZE/2);
				if(sigma.val[0] > 0.0001){
					dif += (p==W_FILTER_SIZE/2)*(q==W_FILTER_SIZE/2)*(k==r)/sigma.val[0];
					dif -= s.val[0]*s.val[0]/(sigma.val[0]*sigma.val[0]*sigma.val[0]* W_FILTER_SIZE*W_FILTER_SIZE*FILTER_NUMBER );
				}
				else{
					dif += (p==W_FILTER_SIZE/2)*(q==W_FILTER_SIZE/2)*(k==r)/0.0001;
				}
				delta = cvGet2D(OutImageD[k], y+q-W_FILTER_SIZE/2, x+p-W_FILTER_SIZE/2);
				sum += dif*delta.val[0];
			}
		}
		}
		}
		s.val[0]=sum;
		cvSet2D( InImageD[k], y, x, s);
		//cout << "sigma:" << sigma.val[0] << endl;
		//cout << "ATAI: " << sum << endl;
	}
	}
//		ShowImage("Dif",DifImage[k]);
//		cvWaitKey(0);
	}
	cvReleaseImage(&SigmaImage);
}


//å∏éZê≥ãKâªÇÃî˜ï™ÇÃåvéZ
void CalcSubNorm( IplImage *InImageD[FILTER_NUMBER],  IplImage *OutImageD[FILTER_NUMBER] ){

	CvScalar s, delta;
	int X = OutImageD[0]->width, Y = OutImageD[0]->height;
	double dif, sum;


	//î˜ï™ÇÃåvéZ
	for(int k=0 ; k<FILTER_NUMBER ; k++){
	InImageD[k] = cvCreateImage(cvGetSize(OutImageD[k]), IPL_DEPTH_32F, 1);
	for(int y=0 ; y<Y ; y++){
	for(int x=0 ; x<X ; x++){
		sum=0;
		for(int q=0 ; q<W_FILTER_SIZE ; q++){
		for(int p=0 ; p<W_FILTER_SIZE ; p++){
		for(int r=0 ; r<FILTER_NUMBER ; r++){
			dif=0;
			if(x+p-W_FILTER_SIZE/2>=0 && y+q-W_FILTER_SIZE/2>=0 && x+p-W_FILTER_SIZE/2<X && y+q-W_FILTER_SIZE/2<Y){
				dif  += (p==W_FILTER_SIZE/2)*(q==W_FILTER_SIZE/2)*(k==r);
				dif  -= 1.0/(W_FILTER_SIZE*W_FILTER_SIZE*FILTER_NUMBER );
				delta = cvGet2D(OutImageD[k], y+q-W_FILTER_SIZE/2, x+p-W_FILTER_SIZE/2);
				sum  += dif*delta.val[0];
			}
		}
		}
		}
		s=cvGet2D( InImageD[k], y, x);
		s.val[0]=sum;
		cvSet2D( InImageD[k], y, x, s);
//		cout << "ATAI: " << sum << endl;
	}
	}
	}
}


//PoolDeltaÇÃåvéZ
IplImage *DeltaPool( IplImage *Image, IplImage *NextImageD ){

	IplImage *ImageD = cvCreateImage( cvGetSize(Image), IPL_DEPTH_32F , 1);
	int size=2;//ÉvÅ[ÉäÉìÉOëwÇÃÉTÉCÉY
	int X = Image->width, Y = Image->height;
	int imax, jmax;
	double max;
	CvScalar s;

	for( int y=0 ; y<Y/size; y++ ){
	for( int x=0 ; x<X/size; x++ ){

		for( int i=0 ; i<size ; i++){
		for( int j=0 ; j<size ; j++){
			s = cvGet2D(Image,size*y+i,size*x+j);
			if(i==0 && j==0){
				max = s.val[0];
				imax=0;
				jmax=0;
			}
			else if( s.val[0] > max ){
				imax=i;
				jmax=j;
			}
		}
		}

		for( int i=0 ; i<size ; i++){
		for( int j=0 ; j<size ; j++){
			if(i==imax && j==jmax){
				s = cvGet2D(NextImageD,y,x);
				cvSet2D(ImageD,size*y+i,size*x+j,s);
//				if(s.val[0]>1000)printf("Pool:%f\n",s.val[0]);
			}
			else{
				s.val[0] = 0;
				cvSet2D(ImageD,size*y+i,size*x+j,s);
			}
		}
		}

	}
	}

	s.val[0] = 0;
	if(X%2==1) for( int y=0 ; y<Y; y++ ) cvSet2D(ImageD,y,X-1,s);
	if(Y%2==1) for( int x=0 ; x<X; x++ ) cvSet2D(ImageD,Y-1,x,s);


	//äàê´âªä÷êîÇÃî˜ï™ÇÃåvéZ
	for( int y=0 ; y<Y; y++ ){
	for( int x=0 ; x<X; x++ ){
		s = cvGet2D(Image,y,x);
		if(s.val[0] < 0){
			s.val[0] = 0;
			cvSet2D(ImageD,y,x,s);
		}
	}
	}

	return ImageD;
}


//ConvDeltaÇÃåvéZ
IplImage *DeltaConv( IplImage *NextImageD[FILTER_NUMBER], float H[][FILTER_SIZE][FILTER_SIZE] ){

	IplImage *ImageD = cvCreateImage( cvGetSize(NextImageD[0]), IPL_DEPTH_32F, 1);
	double output;
	int X = ImageD->width, Y = ImageD->height;
	CvScalar s;

	for(int y=0 ; y<Y ; y++){
	for(int x=0 ; x<X ; x++){
		output=0.0;
		for(int k =0 ; k <FILTER_NUMBER ;  k++){
		for(int py=0 ; py<FILTER_SIZE   ; py++){  // FILTER_SIZE * FILTER_SIZE ãﬂñT
		for(int px=0 ; px<FILTER_SIZE   ; px++){
			if(x+px-FILTER_SIZE/2>=0 && y+py-FILTER_SIZE/2>=0 && x+px-FILTER_SIZE/2<X && y+py-FILTER_SIZE/2<Y){
				s = cvGet2D( NextImageD[k], y+py-FILTER_SIZE/2, x+px-FILTER_SIZE/2);
				s.val[0]=Max(s.val[0],0);
//				if(s.val[0]>1000)printf("Conv:%f\n",s.val[0]);
				output +=  H[k][py][px]*s.val[0]; //èoóÕâÊëfÇÃåvéZ
			}
		}
		}
		}
		s.val[0] = output;
		cvSet2D( ImageD, y, x, s );
	}
	}
	return ImageD;
}


//fh2,fb2ÇÃçXêV
void UpdateF2(IplImage *Image ){

	CvScalar s;
	float w1,w2,w3; //èdÇ›åWêî

	w1=(float)(-ALPHA*1.0/UNIT);
	w2=(float)(MU*1.0/UNIT);
	w3=(float)( -(ALPHA*1.0/UNIT) * (LAMBDA*1.0/UNIT) );

	for( int i=0 ; i<fNUMBER3 ; i++ ){

//		D_fb2[i] = w1 * deltaF2[i] + w2 * D_fb2[i] + w3 * fb2[i];
		D_fb2[i] = UpdateFormula(deltaF2[i], D_fb2[i],fb2[i]);
		fb2[i] += D_fb2[i];

		for( int j=0 ; j<fNUMBER2 ; j++ ){
			s = cvGet2D( Image, 0, j );
//			D_fh2[i][j] = w1 * deltaF2[i] * s.val[0] + w2 * D_fh2[i][j] + w3 * fh2[i][j];
			D_fh2[i][j] = UpdateFormula(deltaF2[i] * (float)s.val[0], D_fh2[i][j],fh2[i][j]);
			fh2[i][j] += (float)(D_fh2[i][j]/10.0);
		}

	}

}


//fh,fbÇÃçXêV
void UpdateF(IplImage *Image ){
	int X = Image->width, Y = Image->height;
	CvScalar s;
	float w1,w2,w3; //èdÇ›åWêî

	w1=(float)(-ALPHA*1.0/UNIT);
	w2=(float)(MU*1.0/UNIT);
	w3=(float)(-(ALPHA*1.0/UNIT) * (LAMBDA*1.0/UNIT) );


	for( int i=0 ; i<fNUMBER2 ; i++ ){
//		D_fb[i] = w1 * deltaF[i] + w2 * D_fb[i] + w3 * fb[i];
		D_fb[i] = UpdateFormula(deltaF[i],D_fb[i],fb[i]);
		fb[i] += D_fb[i];
		for(int y=0 ; y<Y ; y++){
		for(int x=0 ; x<X ; x++){
			s = cvGet2D( Image, y, x );
//			D_fh[i][y*X+x] = w1*deltaF[i]*s.val[0] + w2*D_fh[i][y*X+x] + w3 * fh[i][y*X+x];
			D_fh[i][y*X+x] = UpdateFormula(deltaF[i]*(float)s.val[0],D_fh[i][y*X+x],fh[i][y*X+x]);
			fh[i][y*X+x]  += D_fh[i][y*X+x];
		}
		}
	}

}


//h,bÇÃçXêV
void Update(IplImage *Image[FILTER_NUMBER],IplImage *ImageD,float H[][FILTER_SIZE][FILTER_SIZE],
float B,int input_number,float Hd[][FILTER_SIZE][FILTER_SIZE], float Bd ){

	float delta_h[FILTER_SIZE][FILTER_SIZE];
	float delta_b;
	int X = ImageD->width, Y = ImageD->height;
	CvScalar s, delta_s;
	float w1,w2,w3; //èdÇ›åWêî

	w1=(float)(-ALPHA*1.0/UNIT);
	w2=(float)(MU*1.0/UNIT);
	w3=(float)( -(ALPHA*1.0/UNIT) * (LAMBDA*1.0/UNIT) );


	delta_b = 0;

	for(int k=0 ; k<input_number ; k++){

		//delta_hÇÃèâä˙âª
		for(int i=0 ; i<FILTER_SIZE ; i++) for(int j=0 ; j<FILTER_SIZE ; j++) delta_h[i][j] = 0;


		for(int y=0 ; y<Y ; y++){
		for(int x=0 ; x<X ; x++){
			s = cvGet2D( Image[k], y, x );
			for(int py=0 ; py<FILTER_SIZE   ; py++){  // FILTER_SIZE * FILTER_SIZE ãﬂñT
			for(int px=0 ; px<FILTER_SIZE   ; px++){
				if(x+px-FILTER_SIZE/2>=0 && y+py-FILTER_SIZE/2>=0 && x+px-FILTER_SIZE/2<X && y+py-FILTER_SIZE/2<Y){
					delta_s = cvGet2D( ImageD, y+py-FILTER_SIZE/2, x+px-FILTER_SIZE/2 );
					delta_h[py][px] +=(float) (delta_s.val[0] * s.val[0]);
					delta_b    += (float)delta_s.val[0];
				}
			}
			}
		}
		}

		//delta_hÇ…ë„ì¸
		for(int i=0 ; i<FILTER_SIZE ; i++) for(int j=0 ; j<FILTER_SIZE ; j++){
//			Hd[k][i][j] = w1*delta_h[i][j] + w2 * Hd[k][i][j] + w3 * H[k][i][j];
			Hd[k][i][j] = UpdateFormula(delta_h[i][j],Hd[k][i][j],H[k][i][j]);
	H[k][i][j] += Hd[k][i][j];
		}

	}

//	Bd= w1*delta_b + w2*Bd + w3*B;
	Bd = UpdateFormula(delta_b,Bd,B);
	B += Bd;
}


//ämó¶ìIå˘îzç~â∫ñ@
float UpdateFormula(float a1, float a2, float a3){
	if(LearningCount<0) Error("Error:LearningCount value");

	float w1 =(float)(-ALPHA*1.0/UNIT / pow((double)REDUCTION, (double)(LearningCount/STEPSIZE)));
	float w2 =(float)(    MU*1.0/UNIT);
	float w3 =(float)( -ALPHA*1.0/UNIT / pow((double)REDUCTION, (double)(LearningCount/STEPSIZE)) * (LAMBDA*1.0/UNIT));

	return w1*a1 + w2*a2 + w3*a3;

}


//äwèKéûÇ…égópÇ∑ÇÈdeltaÇÃóÃàÊÇâï˙
void ReleaseDelta(){
	cvReleaseImage( &FcImageD );	

	for( int j=0 ; j<LAYER         ; j++ ){  //LAYER:ëwÇÃêî
	for( int i=0 ; i<FILTER_NUMBER ; i++ ){  //FILTER_NUMBER:ï¿óÒèàóùÇÃêî
		cvReleaseImage(   &ConvImageD[j][i] );
		cvReleaseImage(   &PoolImageD[j][i] );
		cvReleaseImage(&SubNormImageD[j][i] );
		cvReleaseImage(&DivNormImageD[j][i] );
		if(j==LAYER-1)cvReleaseImage(&DivNormImageD[j+1][i] );
	}
	}
}

//ã≥étêMçÜÇì¸óÕÇ≥ÇπÇÈÅiÉ}ÉjÉÖÉAÉãÉÇÅ[ÉhÇÃäwèKÇ≈égópÅj
int TrueNumber(){
	int TrueNum;

	while(1){
		printf("True Number:");
		scanf("%d",&TrueNum);
		if(0<=TrueNum && TrueNum<RecogNum) break;
		else printf("Select 0~%d\n",RecogNum-1);
	}

	return TrueNum;
}